## 1、函数的基本思想
函数强调代码的复用性，即可以作为一个整体被反复使用。函数可以被其他部分的代码使用，称为调用；也可以被自身调用，即递归。把可以重复使用的代码封装成一个函数，用以实现特定功能，这种模块化的编程方式更符合人的思考方式（使用工具来必要知道所有原理），一定程度上减少了重复造轮子的工作量。

## 2、函数的定义、声明和调用
函数的定义和声明（也叫函数的原型）在形式上的区别是:函数体（即大括号）；以分号结尾。
```cpp
void myfun(){cout<<"This is my fun.";} // 这是定义
void myfun(); // 这是声明
```
如果一个函数的定义写在它被调用之后，则必须在调用前先声明。(声明-调用-定义 ; 定义-调用）
调用函数时，不可以与返回类型和参数类型！但必须有小括号，如 myfun()。即使在没有实际参数的情况下，也必须有空的小括号，不能漏掉。

## 3、函数的返回
一般情况下，函数都有返回类型（void 也是一种返回类型）(特例：第 10 章介绍的构造函数和析构函数没有返回类型)。一个函数如果没有返回值，那么它的返回类型是 void。返回类型不是 void 的函数都必须以 return 语句结束。返回类型是 void 的函数也能以 return 语句结束（即 return）。如果一个函数的返回类型不是 void，且在不同情况下返回的值不同，那么一定要保证在每个逻辑分支下都有 return 语句。如果 return 语句返回的变量的类型和函数的返回类型不同，会进行自动类型转换。
```cpp
//函数的定义：
int myfun() {return 6.67;}
//函数的调用：
double x; x = myfun(); // x 被赋值为 6
```

## 4、函数的参数

当参数为值传递时，被调函数中对形参的修改不影响主调函数中实参的值。如果实参和形参的类型不同，会进行[[Summary|自动类型转换]]。

## 5、变量的作用范围（作用域）

程序块是以大括号作为边界的一段代码。在一个程序块中定义的变量（即局部变量）只能在这个程序块里使用，在该程序块结束时会消亡/释放（即该程序块为该局部变量的作用域）。第 7 章介绍的用`new` 定义的动态变量不是任何程序块中的变量，不 `delete` 就不会消亡。整个源文件可以看作最大的程序块。全局变量的作用范围不是整个源文件，在函数外部定义的全局变量，默认具有文件作用域，从定义处开始到文件末尾有效。在内部程序块中定义的变量会屏蔽在外部程序块中定义的同名变量。
一个特例是在 for 循环控制行中定义的变量，虽不在大括号里，但属于大括号里的程序块。
```cpp
int main(){
    int i = 27;
    for(int i=0; i<10; i++)
    cout << i; //输出 0-9
    cout << i; //输出 27
    return 0;
}

int main(){
    int i = 27;
    for(i=0; i<10; i++)
    cout << i; //输出 0-9
    cout << i; //输出 10
    return 0;
}
```

注意避免混淆:如果内部程序块没有定义与外部程序块同名的变量，而是直接修改了在外部程序块中定义的变量，那么其修改结果自然会延续到外部程序块中。例如 ：
```cpp
int i=0; for(i=0; i<20; ++i)cout<<i; //在循环结束后，i 的值就是 20。
```

## 6、变量的存储类别

四种存储类型：auto（自动）、extern（外部）、register（寄存器）、static（静态）。

在函数中定义变量时不说明存储类别，即默认为自动变量。在程序运行过程中，进入一个程序块时给其中的自动变量分配内存空间，离开时收回空间。因此，如果多次调用同一个函数，第 i 次调用时占用的内存位置可能与第 i-1 次时不同。

在一个全局变量的作用域之外的程序块中，可以使用 extern 声明该全局变量以访问它。

静态变量的内存空间是在编译时分配的，且在整个程序运行期间不会被收回。静态局部变量在第一次运行到其它语句时完成初始化，且该语句只运行一次。因此，静态局部变量的数值在函数返回后也可以保留（但不能在其它函数中访问）。静态全局变量和静态函数不能被其它源文件访问（即使用 extern 也不行）。static还可以用在函数声明或定义中，使该函数只能用于该源文件，不能被其他源文件调用。未被初始化的静态变量都被系统初始化为0。

例一（静态变量）：
```cpp
#include <iostream>
using namespace std;

void testFunction() {
    static int count = 0;  // 静态局部变量
    count++;
    cout << "count = " << count << endl;
}

int main() {
    testFunction();  // 输出：count = 1
    testFunction();  // 输出：count = 2
    testFunction();  // 输出：count = 3
    testFunction();  // 输出：count = 4
    
    cout << count;  // 错误！count在main函数中不可见
    return 0;
}
```
例二（静态常量）
```cpp
void processData(int data) {
    static const double PI = 3.1415926535;  // 只初始化一次
    static const int MAX_SIZE = 1000;       // 只初始化一次
    
    double result = data * PI;
    int buffer[MAX_SIZE];
    // ...
}

int main() {
    for(int i = 0; i < 10000; i++) {
        processData(i);  // PI和MAX_SIZE只初始化一次，而不是每次调用都初始化
    }
}
```
## 7、数组作为函数的参数

当形参写成数组形式时（如 int a\[ \]），本质上是个指向 int 变量的指针（第 7 章会讲）。如果实参是数组名，那么会把该数组的起始地址赋值给这个形参指针。被调函数可以通过该指针修改主调函数中的数组元素。数组作为实参时不带\[\]。

将多维数组作为函数的形式参数时，要指定除了第一维以外所有维的大小。例如形参为二维数组的情况：int a\[\]\[10\]，其本质是一个指向 5x10 二维 int 数组的指针。

## 8、函数的参数带默认值（缺省值）

当函数的参数带默认值时，要注意默认值的位置。在声明-调用-定义的情况下，参数的默认值与在函数的声明语句里。在定义-调用的情况下，参数的默认值与在函数头里。缺省参数无论有几个，都必须放在参数序列的最后，即函数调用时若某个参数省略，则其后的参数皆应省略而取其缺省值。

## 9、内联函数
内联函数在编译时用函数体替换函数调用语句，以消除运行时的调用开销（时间换空间）。内联的优点是既能重用代码又没有调用开销，缺点是会导致编译后的代码膨胀。内联函数的定义应该写在调用之前，并在函数头前加上关键字 inline。
```cpp
#include <ostream>
inline float cube (float s) {return s*s*s;}
int main(){
	cout<<cube(2);
	return 0;
	}
```
在什么情况下不适合使用内联函数？函数体内有循环导致函数执行时间大于调用成本；函数代码较长导致内存消耗大。

## 10、函数重载与函数模板

**重载函数**：函数名相同，但参数表（参数个数、参数类型）不同。注意，如果两个函数的返回类型不同但参数表相同，那么它们不可以重名，有的时候因为默认值也可能导致编译器无法判断调用哪一个函数而导致报错。
```cpp
int max (int a1,int a2);//只有这个是系统自带的
int max (int a1,int a2,int a3);
int max (int a1,int a2,int a3);
```

**函数模版**：如果一组重载函数只是参数的类型不一样，程序的逻辑完全一样，那么可以写成一个函数模版，实现类型的参数化（泛型化）。函数模板不是函数，它在运行时根据调用语句中实参的数据类型产生一个对应的函数。如果多次调用，不同的实参类型会产生不同的函数，相同的实参类型使用同一个函数。函数模板在声明和定义时都要加上 `template <class T>`。定义多个函数模板时，每个函数模板都要写属于各自的 `template <class T>`。如果一个函数模板中有多个不同的参数化的类型，则每种类型对应一个 class，例如：`template <class T, class S, class U>`
```cpp
template <class T>
T max(T a,T b){return a>b?a:b;}
```
## 11、递归函数

在写递归函数时，尤其要注意的是递归的终止条件与回溯的过程。一个递归函数的函数体中包括：递归调用前的处理 ;递归调用 ;递归调用后的处理（上述第一步需检查递归的终止条件是否成立，第三步即回溯时执行的操作）。用递归函数处理数组时，特别注意数组的起始地址和长度在递归过程中的变化。递归调用必须有条件，否则会死循环。必须有递归终止的条件。对递归函数的每次调用都需要新的内存空间。由于很多调用活动同时进行，操作系统在处理过大的n时可能会耗尽内存发生溢出。
例：数字旋转方阵（蛇阵）
```cpp
#include <iostream>
using namespace std;

//main函数
int p[20][20];
int main() {
    int row, col, size;
    cout << "请输入蛇阵的规模：";
    cin >> size;
    fill(1,0,size);
    for (row = 0; row < size; ++row) {
        cout << endl;
        for (col = 0; col < size; ++col) 
            cout << p[row][col] << '\t';
    }
    return 0;
}

//fill函数
void fill(int number, int begin, int size) {
    int i, row = begin, col = begin;
    if (size == 0) return;
    if (size == 1) { p[begin][begin] = number; return; } //终止条件
    p[row][col] = number; ++number;
    for (i=0; i<size-1; ++i)
    {
        ++row; p[row][col] = number; ++number;
    }
    for (i=0; i<size-1; ++i)
    {
        ++col; p[row][col] = number; ++number;
    }
    for (i=0; i<size-1; ++i)
    {
        --row; p[row][col] = number; ++number;
    }
    for (i=0; i<size-2; ++i)
    {
        --col; p[row][col] = number; ++number;
    }
    fill(number, begin+1, size-2); // 递归调用
}
```

