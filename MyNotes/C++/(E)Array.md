## 1、定义数组
定义数组时，必须用常量规定数组的大小。绝对禁止用变量。
```cpp
int n = 10; int a[n]; // 这是错的！因为 n 是变量【赋予值的变量也是变量！！！】
const int n = 10; int a[n]; // 这是对的，因为 n 是符号常量
const int n; cin >> n; int a[n]; // 这是错的【常量只能初始化，不可以赋值！不可以赋值！】

float x[5]={-1.1,0.2,33.0,4.4,5.05}
```
定义数组时如果没有初始化，那么所有元素的初始值都是随机值。如果给一部分元素初始化，那么其余元素的初始值都是零。如果数组是全局变量，则全部初始化为0。
数组≠数组元素。对于一维数组而言，数组元素是单个变量。

## 2、数组名
不带中括号的数组名表示该数组的起始地址。
用 cout<<输出地址分两种情况：如果是字符串类型的地址，那么无论该地址是字符数组名、字符指针还是字符变量的地址，都输出字符串；如果不是字符串类型的地址，那么输出地址。不能给数组名赋值。
```cpp
例如 int x[10]; cin>>x; // 错误，无法编译。
虽然 char y[10]; cin>>y; // 可以编译，但这不是给 y 赋值，而是给 y 的元素赋值。
```
为了给数组赋值，可以使用头文件`cstring`中的函数
```cpp
memcpy(b,a,sizeof(int)*k);
memcpy(b,a,sizeof(double)*k);//从浮点型的数组a复制k个到数组b
memset(a,0,sizeof(a));//对a进行初始化
```
## 3、数组元素的下标

对于元素个数为常量 N 的数组，下标的合法范围是从 0 到 N-1。不能用浮点数作为下标。使用 for 循环处理数组元素时要注意下标的取值。如果在循环过程中会让下标超出合法范围，很可能产生错误结果。尤其要注意 `a[i+1]`, `b[j-1]`之类的情况，避免 i+1 可取到 N, j-1 可取到 -1。

## 4、基于数组的排序

二分查找的前提是数组中的元素已经按数值顺序排列好。二分查找既可以用循环的方法，也可以采取递归。这是循环实现的代码模版（这种方式更便于得到索引）：
```cpp
#include <stdio.h>

// 循环实现二分查找
int binarySearch(int arr[], int size, int target) {
    int left = 0;
    int right = size - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出
        
        if (arr[mid] == target) {
            return mid;  // 找到目标，返回索引
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1; // 目标在左半部分
        }
    }
    
    return -1;  // 未找到
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    int size = sizeof(arr) / sizeof(arr[0]);
    int target = 13;
    
    int result = binarySearch(arr, size, target);
    if (result != -1) {
        printf("元素 %d 在索引 %d 处\n", target, result);
    } else {
        printf("元素 %d 未找到\n", target);
    }
    
    return 0;
}
```
注意，防止溢出的原因是
```cpp
int left = 2000000000;
int right = 2000000000;

// 错误的中间值计算
int mid_wrong = (left + right) / 2;
// 实际计算过程：
// left + right = 2000000000 + 2000000000 = 4000000000
// 但 int 最大约 21亿（2147483647）
// 所以 left + right 会溢出变成负数！
// 然后除以2得到错误的mid
```

递归函数实现的例子（可以判断某个元素是否存在）：[[(G)Pointer#7、指针数组与多级指针|递归函数实现二分查找]]

## 5、二维数组

二维数组的第 i 行的末尾和第 i+1 行的开头在内存中是连接在一起的。
二维数组的每一个元素都是一个一维数组。如：
```cpp
int a[4][5]// a[i] 是一维 int 数组。
```
这意味着 `a[i]` 具备数组名的特征：可以输出，不可被赋值。

## 6、字符串以及字符串的输入输出
**C语言风格字符串**
```cpp
char ch[] = {'H','e','l','l','o','\0'};
char ch[] = {"Hello"};
char ch[] = "Hello";
```
注意，'a'和"a"是不一样的


**cin**:
当使用 `cin>>字符数组名` 来输入字符串时，若输入字符的数量大于数组长度，则会发生下标越界的 bug。输出字符串是通过 `cout<<字符串的起始地址`来实现的，输出到 '\0' 为止。如果字符数组中没有 '\0', 那么它就没有储存一个完整的字符串，输出该数组名会出错。
```cpp
char a[10];
cin >> a; //输入直到遇到空格为止，存储了以 '\0' 结尾的字符串，但输入 10 个以上的字符时会越界
cin.getline(a, 10); // a 存储了以 '\0' 结尾的字符串，且不会越界，如果输入的字符超过了9个，那么只会读取前9个
for(int i=0; i<10; ++i) cin.get(a[i]); // 可能会读到 '\n', 但不会变成 '\0'
```
用循环处理字符串时，要注意根据 '\0' 来判断字符串是否结束，并及时结束循环，否则可能产生错误。注意，是空字符'\0', 不是空格字符，也不是 '0' ('\0' 的 ASCII 码是 0)。
cin会把结束字符留在缓冲区，因此要加以小心。可以用`cin.ignore()`来清除缓冲区遗留的内容

**cin.getline**:
`cin.getline `的第一个参数类型是一维字符数组，所以可以用一维字符数组的数组名（也就是一级字符指针），但不能用二维字符数组的数组名。
比如定义了 `char a[4][5];` 后不能用 a 作为 cin.getline 的第一个参数，但可以用 `a[0]`, `a[1]` 等作为 `cin.getline `的第一个参数。
```cpp
char a[4][5];
cin.getline(a[0], 5); // 正确
cin.getline(a, 5); // 语法错误
```
cin.getline 的第二个参数规定了读取字符的（最大）数量，该数量是包含 '\0' 的。例如第二个参数为 10，而输入了 10 个字符，那么只有前 9 个字符会被存入数组，并在末尾添加 '\0'。
```cpp
char a[10];
cin.getline(a, 10); // 输入 0123456789
cout << a; // 输出 012345678
```
用 cin.getline 读取的一行字符串是不包括它的第三个参数的（即结束字符），该字符会被 '\0' 取代，因此后续在判断字符串结尾时应以 '\0' 为标志。
```cpp
char a[100];
cin.getline(a, 20, ':'); // 这可以
cin.getline(a, 20); // 这也可以
cin.getline(a, ':'); // 这不可以！
```

**cin.get**:
可以读取单个字符(任何字符）：
```cpp
ch=cin.get();
```
也可以读取字符数组,这个时候会自动加空字符，和cin.getline()基本类似，但与cin.getline的区别在于结束字符的处理方式，该函数把结束字符留在缓冲区，而cin.getline则从输入缓冲区删除：
```cpp
cin.get(字符数组，数组长度，结束标记);
cin.get(字符数组，数组长度);
```

|             |                                | 关于"cin>>"、"cin.getline"和"cin.get"的使用对比                                                   |                                                 |
| ----------- | ------------------------------ | ---------------------------------------------------------------------------------------- | ----------------------------------------------- |
|             | 每次读取的内容                        | 对字符串的处理                                                                                  | 适用场景                                            |
| cin>>       | 空白字符（空格符、回车符、制表符）前的内容（不包括空白字符） | 把读取的字符都存储在字符数组里，并在读取的最后一个字符之后添加一个空字符，表示字符串结尾                                             | 读取不含空白字符的字符串（常表现为一个单词）；还可以读取其它类型的数据，如整数或实数、单个字符 |
| cin.get     | 一个任何字符（包括空白与非空白字符）             | 可通过每次读取一个字符、循环（到输入回车符停止）读取的方式来存储字符串中的每一个字符，但用户输入的回车依然是回车符，并不会被处理成空字符，因此严格意义上讲，这并不是一个字符串。 | 适用于需要读取并存储空白字符的场景；适用于根据每个字符来依次处理的场景             |
| cin.getline | 结束符（默认是回车符）前的内容（通常是一行），包括结束符在内 | 把读取的字符都存储在字符数组里，末尾的结束符（默认是回车符）会被替换为空字符，表示字符串结尾                                           | 适用于一次读取一句话（包含空格符的多个单词）的场景                       |



## 7、字符串处理函数
| 函数                   | 作用                                                                                                                            |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `strcpy(dst, src)`   | 将字符串从 src 复制到 dst。函数的返回值是 dst 的地址                                                                                             |
| `strncpy(dst,src,n)` | 至多从 src 复制 n 个字符到 dst。函数的返回值是 dst 的地址                                                                                         |
| `strcat(dst, src)`   | 将 src 拼接到 dst 后。函数的返回值是 dst 的地址                                                                                               |
| `strncat(dst,src,n)` | 从 src 至多取 n 个字符拼接到 dst 后。函数的返回值是 dst 的地址                                                                                      |
| `strlen(s)`          | 返回字符串 s 的长度，即字符串中的字符个数                                                                                                        |
| `strcmp(s1, s2)`     | 比较 s1 和 s2。如果第一个不匹配的字符的ASCII码 s1>s2，返回值为正数；如果 s1=s2，返回值为 0；如果第一个不匹配的字符的ASCII码 s1<s2，返回值为负数。如果第一个数组已经结束而第二个数组还没有结束，那么认为第一个数组更小 |
| `strncmp(s1, s2, n)` | 与 strcmp 类似，但至多比较 n 个字符                                                                                                       |
| `strchr(s, ch)`      | 返回一个指向 s 中第一次出现 ch 的地址                                                                                                        |
| `strrchr(s, ch)`     | 返回一个指向 s 中最后一次出现 ch 的地址                                                                                                       |
| `strstr(s1, s2)`     | 返回一个指向 s1 中第一次出现 s2 的地址                                                                                                       |
| `strlwr(s1)`         | 将字符串中大写字母转换为小写字母                                                                                                              |
| `strupr(s1)`         | 将字符串中小写字母转换为大写字母                                                                                                              |

strcpy 和 strcat 都有两个参数，第一个参数是 dst（目的地），第二个参数是 src（来源）。src 字符串包含从 src 地址开始直到第一个 '\0' 为止的所有字符，与字符数组的大小无关。使用 strcpy 时，要在 dst 数组中留够足以存下 src 字符串的空间，因此必须使用分配了空间的指针，且不能是字符串常量。使用 strcat 时，要在 dst 数组中留够足以存下拼接后的整个字符串的空间。如果 dst 数组的空间不足，strcpy 和 strcat 会修改位于数组之后的内存空间，造成 bug。要将字符串按长度排序，可用 strlen 获取字符串长度，用 strcpy 来交换两个字符串（需要另外定义一个数组作为中转平台）。要比较两个字符串是否相同，可使用 strcmp 函数，其返回值为 0 时表示相同。

## 8、关于一些常见的但是很容易混淆的基础知识：

###### 关于"字符"、"字符数组"和"字符串"的概念对比：
|      | 概念                   | 注意事项              |
| ---- | -------------------- | ----------------- |
| 字符   | 单个 char 类型的数据，常量有单引号 | 可以转换成 ASCII 表中的编码 |
| 字符数组 | 数组，每个元素都是 char 类型的变量 | 数组名表示第 0 个元素的地址   |
| 字符串  | 一串连续的字符，常量有双引号       | 必须以空字符结尾          |

###### 关于"空字符"、"空格字符"、"空白字符"、"字符零"的概念对比：
|      | 代码    | ASCII 码 | 含义                    |
| ---- | ----- | ------- | --------------------- |
| 空字符  | '\0'  | 0       | 可表示字符串结尾              |
| 空格字符 | ' '   | 32      | 空格这个字符，可简称为空格符        |
| 空白字符 | N/A 注 | N/A 注   | 空格符、回车符和制表符的统称，不包括空字符 |
| 字符零  | '0'   | 48      | 数字零这个字符               |

注：N/A (Not applicable)，表示内容并不适用，在填表时多见。

## 9、冒泡排序与选择排序：
**冒泡排序**：
```cpp
#include <iostream>
using namespace std;

template <class T>
void bubblesort(T a[], int size);

int main()
{
    int k, array[] = {2, 5, 1, 9, 10, 0, 4, 8, 7, 6};

    bubblesort(array, 10);

    for (k = 0; k < 10; ++k)
        cout << array[k] << " ";
    return 0;
}

template <class T>
void bubblesort(T a[], int size)
{
    for (int i = 1; i < size; ++i) { // 控制 size-1次起泡
        bool flag = false; // flag记录一趟起泡中有没有发生过交换
        for (int j = 0; j < size - i; ++j) {
            if (a[j + 1] < a[j]) {
                T tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
                flag = true;
            }
        }
        if (!flag) break; // 一趟起泡中没有发生交换，排序提前结束
    }
}
```
**选择排序：**
```cpp
#include <iostream>
using namespace std;

template <class T>
void selectSort(T a[], int size);

int main()
{
    int array[] = {2, 5, 1, 9, 10, 0, 4, 8, 7, 6};

    selectSort(array, 10);

    for (int k = 0; k < 10; ++k)
        cout << array[k] << " ";
    return 0;
}

template <class T>
void selectSort(T a[], int size)
{
    for (int lh = 0; lh < size; ++lh) { // 依次将正确的元素放入a[lh]
        int min = lh;
        for (int k = lh; k < size; ++k) { // 找出lh到最后一个元素中的最小元素下标min
            if (a[k] < a[min]) 
                min = k;
        }
        T tmp = a[lh]; // 交换lh和min的值
        a[lh] = a[min];
        a[min] = tmp;
    }
}
```