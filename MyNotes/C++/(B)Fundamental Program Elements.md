## 1、程序注释
C++：`// ` 开始到本行结束
C风格：`/*` 到 `*/`之间的所有文字
块注释：`ctrl` +`shift` + `/`
## 2、预编译指令
##### 库包含：
```cpp
#include <system_filename> //包含了一个系统库
#include "user_filename"//包含了一个用户自定义的库
```
[[Summary#常用头文件|常用头文件总结]]
##### 宏定义：
宏是一种根据特定规则进行文本替换的操作，包括不带参数的宏和带参数的宏不带参数的宏通常用来定义符号常量:
```cpp
//格式：#define  标识符   替换文本

#define PI 3.14159
```
带参数的宏定义一些较为复杂的操作:
```cpp
#define   宏名（参数表）  替换文本

#define  CIRCLE_AREA(x)  (PI*(x)*(x))
```

## 3、符号常量
用define定义符号常量是C语言的习惯，存在一些问题：无法进行类型检查，简单的字符串的替换容易发生意想不到的错误。因此采用**const**定义符号常量：
```cpp
const double PI = 3.1415926;
```

## 4、主程序
每个程序有且仅有一个名为**main**的函数，它是程序的入口。一个main函数中必须至少有一个return语句，一般是"return 0"。

## 5、名字空间
不同源文件连接成一个可执行文件时，可能造成重名。一个名字空间中不能有重名，不同的名字空间中可以定义相同的实体名
```cpp
using namespace std;
```

## 6、变量与初始化
定义格式：类型   变量名  =  初值  或（初值）
变量完成定义后，类型永不改变

## 7、变量命名
以字母或下划线开头，其他字符为字母、数字、下划线，不可以是[[Summary#保留词|保留词]]

## 8、整型

> [!info] 存储空间
>|        名称        | 占用的内存空间 |          大小限制          |
| :--------------: | :-----: | :--------------------: |
|      基本型int      | 4 byte  | -$2^{31}$~$(2^{31}-1)$ |
| 长整型long/long int | 4 byte  | -$2^{31}$~$(2^{31}-1)$ |
|     短整型short     | 2 byte  | -$2^{15}$~$(2^{15}-1)$ |

32位int的取值范围是-2147483648～2147483647（小心数据溢出）

运算操作：整型数在计算机内通常用**补码**表示。正整数的补码就是其二进制表示，负整数的补码是其绝对值的二进制取反后加1，0的补码是0。对于有符号整型数，正数的最高位一定是0，负数的最高位一定是1。

## 9、无符号整数:

>[!info]
> |  unsigned int  | 0~($2^{32}-1$) |
| :------------: | :------------: |
| unsigned short |    0~65535     |
| unsigned long  | 0~($2^{32}-1$) |

## 10、整型常量与进制
**十进制** 123        **八进制** 0123       **十六进制** 0123  （大于9的数用A～Z表示）
```cpp
int a=123 ; int a=0x123//均是合法的
```
## 11、实型（浮点型）

浮点数在计算机内用尾数和指数来表示。【具体是怎么表示的？】
浮点数是不精确的，在比较是否相等和转换成整数时，务必小心，
很可能有意想不到的结果。

## 12、字符型

a 和'a'毫无关系。
a 是一个变量名，可以是整型、浮点型、字符型等任何类型。
'a'是一个字符常量，用 cout 输出的话会显示小写字母 a。
【大家写代码一定要注意，想明白自己到底是要用哪个】

字符参与计算时实际上是用其 ASCII 码的数值来计算。
【数字字符和整型数字之间如何转换？】

## 13、转义字符

【直接 cout<<"abc">；为什么无法显示"abc"？】
【想输出引号要怎么办？】

## 14、枚举类型

定义枚举类型的语句：enum 类型名{元素表}；
注意该语句定义的是一个类型，不是一个变量。
例如 enum element {Earth, Water, Fire, Air}; 定义了类型element。
被定义好的类型可以用来定义该类型的变量，例如element e;
【怎样给某种枚举类型的变量赋值？】
【元素表中各个元素对应的机内编码是怎样确定的？】
输出枚举类型的变量时，显示的是其内码值，例如：
e = Fire; cout << e; // 显示2，因为Fire对应的机内编码为2
枚举类型在编译时直接替换，不分配内存
## 15、sizeof
[[Summary#size of ()|sizeof()]]的括号里可以放数据类型、变量或表达式。
【int、float、double、char、bool 分别各占多少字节？】

## 16、算术运算
乘法运算符是\*，除法运算符是/，取余数运算符是%。只有整型数才能做取余数的运算，浮点数不行。
整型数、浮点数、字符一起运算时，遵循从小到大自动提升的类型转化规则，任何运算最终都会转换为表达式中最大的类型。
``char → short → int → unsigned → long → float → double``

C++语言中没有乘方运算符，a的3次方要用a\*a\*a来表示。同时，不能用cmath库的`pow()`函数来计算整型数的n次幂,因为返回double需要强制转换，可能截断，浮点数舍入误差导致结果不准确。
```cpp
double pow(double base, double exponent);// 返回double类型，不是整型
```

## 17、强制类型转换

加上目标类型和括号可以进行强制类型转换。
(类型名)(表达式)的意思是对表达式的计算结果进行强制类型转换，而不是先转换表达式中的各个变量后再进行计算。
注意：(int)'0'的结果是48而不是0，(char)0的结果是'\0'而不是'0'。

强制类型转换（以及自动类型转换）改变的是寄存器中的临时值，且数值可能会发生相应的变化，但没有改变内存中的变量。被转换的变量仍保持原来的类型和数值不变。

## 18、赋值运算

赋值表达式会把赋值运算符右边的量转换为左边的数据类型的量。赋值运算符左边必须是个变量，不能是常量或某个运算的表达式。在同一个语句中，先计算，后赋值。多重赋值的顺序是从右到左，每次赋值都转换为赋值运算符左边的数据类型。复合赋值表达式i+=1和自增表达式i++、++i在用作其它表达式的一部分的时候有所不同，i+=1对外而言是个赋值表达式，而i++、++i对外而言是个变量。例如cout<<++i;或cout<<i++;都会输出变量的值（尽管是两个不同的值），但由于cout<<i+=1;等价于cout<<i=i+1;，而cout<<i的结果是cout（<<的优先级高于=），因此该语句是无法编译的（不能用=给cout赋值）。

## 19、输入输出
##### 输出流对象std::cout
```cpp
std::cout<<"hello"<<std::endl;
```
std 是C++中所有标准库的名字空间的名称
：：是作用域限定符，表示它后面的东西属于它前面的作用域
std::endl 表示换行

在连续输入或输出多个变量（或常量、字符串和表达式的计算结果）时，要用>>或<<来分隔各个变量。不能用逗号来分隔，如cin >> a, b;或cout<<a, b;都是错误的！输入多个数据可以用一个cin连续输入，也可以分成多次cin输入。在两个输入语句之间也可以输出。
【cin.get()相比cin>>有什么优势？】
如果不想在输出信息之后换行，就不要输出endl。
cout << a << endl; cout << b;等价于cout << a << endl << b;（但一般不建议把endl放在一行代码的中间，因为endl表示换行，放在中间有点反直觉。）

## 20、程序设计的风格

要注意写注释、缩进对齐、变量命名等等。











